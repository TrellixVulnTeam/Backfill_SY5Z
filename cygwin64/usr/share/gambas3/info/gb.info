#$*[]


_free
m


_get
m
*
(Index)i.
_next
m
*

_put
m

(Value)*;(Index)i.
Bounds
r
.Array.Bounds

Count
r
i

Data
r
p

Dim
r
i

Length
r
i

Max
r
i

#*[]
Array
C
Add
m

(Value)*;[(Index)i]
Copy
m
*[]
[(Start)i(Length)i]
Delete
m
*[]
(Start)i[(Length)i]
Exist
m
b
(Value)*;
ExistByRef
m
b
(Value)*;
Extract
m
*[]
(Start)i[(Length)i]
Fill
m

(Value)*;[(Start)i(Length)i]
Find
m
i
(Value)*;[(Start)i]
FindByRef
m
i
(Value)*;[(Start)i]
Insert
m
*
(Array)*[];[(Pos)i]
Pop
m
*

Push
m

(Value)*;
Reverse
m
*[]

Sort
m
*[]
[(Mode)i]
_get
m
*
(Index)i.
_new
m

[(Size)i.]
_next
m
*

_put
m

(Value)*;(Index)i.
#.

C
ACos
m
f
(Value)f
ACosh
m
f
(Value)f
ASin
m
f
(Value)f
ASinh
m
f
(Value)f
ATan
m
f
(Value)f
ATanh
m
f
(Value)f
Abs
m
v
(Value)v
Access
m
b
(Path)s[(Mode)i]
Acs
m
f
(Value)f
Acsh
m
f
(Value)f
Alloc
m
p
(SizeOrString)v[(Count)i]
Ang
m
f
(X)f(Y)f
Asc
m
i
(String)s[(Pos)i]
Asn
m
f
(Value)f
Asnh
m
f
(Value)f
Atan2
m
f
(X)f(Y)f
Atn
m
f
(Value)f
Atnh
m
f
(Value)f
BChg
m
i
(Value)i(Bit)i
BClr
m
i
(Value)i(Bit)i
BSet
m
i
(Value)i(Bit)i
BTst
m
i
(Value)i(Bit)i
Base64
m
s
(String)s
Base64$
m
s
(String)s
Bin
m
s
(Value)v[(Digits)i]
Bin$
m
s
(Value)v[(Digits)i]
Bool@
m
b
(Pointer)p
Boolean@
m
b
(Pointer)p
Byte@
m
c
(Pointer)p
CBool
m
b
(Value)v
CBoolean
m
b
(Value)v
CByte
m
c
(Value)v
CDate
m
d
(Value)v
CFloat
m
f
(Value)v
CInt
m
i
(Value)v
CInteger
m
i
(Value)v
CLong
m
l
(Value)v
CPointer
m
p
(Value)v
CShort
m
h
(Value)v
CSingle
m
g
(Value)v
CStr
m
s
(Value)v
CString
m
s
(Value)v
CVariant
m
v
(Value)v
Cbr
m
f
(Value)f
Ceil
m
f
(Value)f
Choose
m
v
(Select)i[(Value)v.]
Chr
m
s
(Code)i
Chr$
m
s
(Code)i
Comp
m
i
(String1)s(String2)s[(Mode)i]
Conv
m
s
(String)s(From)s(To)s
Conv$
m
s
(String)s(From)s(To)s
Cos
m
f
(Value)f
Cosh
m
f
(Value)f
DConv
m
s
(String)s
DConv$
m
s
(String)s
DFree
m
l
(Path)s
Date
m
d
[(DateOrYear)v(Month)i(Day)i(Hour)i(Minute)i(Second)i(MilliSecond)i]
Date@
m
f
(Pointer)p
DateAdd
m
d
(Date)d(Period)i(Count)i
DateDiff
m
i
(Date1)d(Date2)d(Period)i
Day
m
i
(Date)d
Deg
m
f
(Radians)f
Dir
m
String[]
(Path)s[(Pattern)s(Filter)i]
Eof
m
b
[(File)Stream;]
Eval
m
v
(Expression)s[(Context)Collection;]
Even
m
b
(Value)i
Exist
m
b
(Path)s[(FollowLink)b]
Exp
m
f
(Value)f
Exp10
m
f
(Value)f
Exp2
m
f
(Value)f
Expm
m
f
(Value)f
Fix
m
v
(Value)v
Float@
m
f
(Pointer)p
Floor
m
f
(Value)f
Format
m
s
(Value)v[(Format)s]
Format$
m
s
(Value)v[(Format)s]
Frac
m
f
(Value)f
Free
m

(Pointer)p
FromBase64
m
s
(String)s
FromBase64$
m
s
(String)s
FromUrl
m
s
(String)s
FromUrl$
m
s
(String)s
Hex
m
s
(Value)v[(Digits)i]
Hex$
m
s
(Value)v[(Digits)i]
Hour
m
i
(Date)d
Html
m
s
(String)s
Html$
m
s
(String)s
Hyp
m
f
(X)f(Y)f
IIf
m
v
(Test)b(True)v(False)v
If
m
v
(Test)b(True)v(False)v
Instr
m
i
(String)s(Pattern)s[(From)i(Mode)i]
Int
m
v
(Value)v
Int@
m
i
(Pointer)p
Integer@
m
i
(Pointer)p
IsAscii
m
b
(String)s
IsBlank
m
b
(String)s
IsBoolean
m
b
(Value)s
IsDate
m
b
(Value)s
IsDigit
m
b
(String)s
IsDir
m
b
(Path)s
IsFloat
m
b
(Value)s
IsHexa
m
b
(String)s
IsInf
m
i
(Value)f
IsInteger
m
b
(Value)s
IsLCase
m
b
(String)s
IsLetter
m
b
(String)s
IsLong
m
b
(Value)s
IsLower
m
b
(String)s
IsMissing
m
b
(Argument)?
IsNan
m
b
(Value)f
IsNull
m
b
(Value)v
IsNumber
m
b
(Value)s
IsPunct
m
b
(String)s
IsSpace
m
b
(String)s
IsUCase
m
b
(String)s
IsUpper
m
b
(String)s
LCase
m
s
(String)s
LCase$
m
s
(String)s
LTrim
m
s
(String)s
LTrim$
m
s
(String)s
Left
m
s
(String)s[(Length)i]
Left$
m
s
(String)s[(Length)i]
Len
m
i
(String)s
Lof
m
l
[(File)Stream;]
Log
m
f
(Value)f
Log10
m
f
(Value)f
Log2
m
f
(Value)f
Logp
m
f
(Value)f
Long@
m
l
(Pointer)p
Lower
m
s
(String)s
Lower$
m
s
(String)s
Mag
m
f
(X)f(Y)f
Max
m
v
(Value)v(Value2)v
Mid
m
s
(String)s[(Pos)i(Length)i]
Mid$
m
s
(String)s[(Pos)i(Length)i]
Min
m
v
(Value)v(Value2)v
Minute
m
i
(Date)d
MkBool
m
s
(Value)b
MkBool$
m
s
(Value)b
MkBoolean
m
s
(Value)b
MkBoolean$
m
s
(Value)b
MkByte
m
s
(Value)c
MkByte$
m
s
(Value)c
MkDate
m
s
(Value)d
MkDate$
m
s
(Value)d
MkFloat
m
s
(Value)f
MkFloat$
m
s
(Value)f
MkInt
m
s
(Value)i
MkInt$
m
s
(Value)i
MkInteger
m
s
(Value)i
MkInteger$
m
s
(Value)i
MkLong
m
s
(Value)l
MkLong$
m
s
(Value)l
MkPointer
m
s
(Value)p
MkPointer$
m
s
(Value)p
MkShort
m
s
(Value)h
MkShort$
m
s
(Value)h
MkSingle
m
s
(Value)g
MkSingle$
m
s
(Value)g
Month
m
i
(Date)d
Now
m
d

Odd
m
b
(Value)i
Pi
m
f
[(Factor)f]
Pointer@
m
p
(Pointer)p
Quote
m
s
(String)s
Quote$
m
s
(String)s
RDir
m
String[]
(Path)s[(Pattern)s(Filter)i(FollowLink)b]
RInstr
m
i
(String)s(Pattern)s[(From)i(Mode)i]
RTrim
m
s
(String)s
RTrim$
m
s
(String)s
Rad
m
f
(Degrees)f
Rand
m
i
(From)i[(To)i]
Realloc
m
i
(Pointer)p(Size)i[(Count)i]
Replace
m
s
(String)s(Find)s(Replace)s[(Mode)i]
Replace$
m
s
(String)s(Find)s(Replace)s[(Mode)i]
Right
m
s
(String)s[(Length)i]
Right$
m
s
(String)s[(Length)i]
Rnd
m
f
[(From)f(To)f]
Rol
m
i
(Value)i(Shift)i
Ror
m
i
(Value)i(Shift)i
Round
m
f
(Value)f[(Round)i]
SConv
m
s
(String)s
SConv$
m
s
(String)s
Scan
m
String[]
(String)s(Pattern)s
Second
m
i
(Date)d
Seek
m
l
(File)Stream;
Sgn
m
i
(Value)v
Shell
m
s
(String)s
Shell$
m
s
(String)s
Shl
m
i
(Value)i(Shift)i
Short@
m
h
(Pointer)p
Shr
m
i
(Value)i(Shift)i
Sin
m
f
(Value)f
Single@
m
g
(Pointer)p
Sinh
m
f
(Value)f
SizeOf
m
i
(Type)i
Space
m
s
(Length)i
Space$
m
s
(Length)i
Split
m
String[]
(String)s[(Separators)s(Escape)s(IgnoreVoid)b(KeepEscape)b]
Sqr
m
f
(Value)f
Stat
m
Stat
(Path)s[(FollowLink)b]
Str
m
s
(Value)v
Str$
m
s
(Value)v
Str@
m
s
(Pointer)p
String
m
s
(Length)i(Pattern)s
String$
m
s
(Length)i(Pattern)s
String@
m
s
(Pointer)p
Subst
m
s
(Pattern)s.
Subst$
m
s
(Pattern)s.
Swap
m
s
(String)s[(Endianness)i]
Swap$
m
s
(String)s[(Endianness)i]
Tan
m
f
(Value)f
Tanh
m
f
(Value)f
Temp
m
s
[(Prefix)s]
Temp$
m
s
[(Prefix)s]
Time
m
d
[(DateOrHour)v(Minute)i(Second)i(MilliSecond)i]
Timer
m
f

Tr
m
s
(String)s
Tr$
m
s
(String)s
Trim
m
s
(String)s
Trim$
m
s
(String)s
TypeOf
m
i
(Value)v
UCase
m
s
(String)s
UCase$
m
s
(String)s
UnBase64
m
s
(String)s
UnBase64$
m
s
(String)s
Unquote
m
s
(String)s
Unquote$
m
s
(String)s
Upper
m
s
(String)s
Upper$
m
s
(String)s
Url
m
s
(String)s
Url$
m
s
(String)s
Val
m
v
(String)s
VarPtr
m
p
(Variable)v
Week
m
i
[(Date)d(Mode)i(Plain)b]
WeekDay
m
i
(Date)d
Year
m
i
(Date)d
#.Array.Bounds


_get
m
i
(Dimension)i
Count
r
i

#.Stat.Perm


_get
m
s
(UserOrGroup)s
Group
r
s

Other
r
s

User
r
s

#.Stream.Lines


_next
m
s

#.Stream.Term


Resize
m

(Width)i(Height)i
Echo
p
b

FlowControl
p
b

H
r
i

Height
r
i

Name
r
s

W
r
i

Width
r
i

#.Symbol


Hidden
r
b

Kind
r
i

Name
r
s

ReadOnly
r
b

Signature
r
s

Static
r
b

Type
r
s

Value
r
v

#Application


Daemon
P
b

Priority
P
i

Args
R
Args

Dir
R
s

Env
R
Env

Handle
R
i

Id
R
i

Name
R
s

Path
R
s

Startup
R
Class

Title
R
s

Version
R
s

#Args


_get
M
s
(Index)i
_next
M
s

All
R
String[]

Count
R
i

Max
R
i

#Array


_@_convert
C
p
?
Clear
m


Remove
m

(Index)i[(Length)i]
Resize
m

(Size)i
_free
m


Bounds
r
.Array.Bounds

Count
r
i

Data
r
p

Dim
r
i

Length
r
i

Max
r
i

Type
r
i

#Boolean[]
Array
C
Add
m

(Value)b[(Index)i]
Copy
m
Boolean[]
[(Start)i(Length)i]
Delete
m
Boolean[]
(Start)i[(Length)i]
Exist
m
b
(Value)b
Extract
m
Boolean[]
(Start)i[(Length)i]
Fill
m

(Value)b[(Start)i(Length)i]
Find
m
i
(Value)b[(Start)i]
Insert
m
Boolean[]
(Array)Boolean[];[(Pos)i]
Pop
m
b

Push
m

(Value)b
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Boolean[]

Sort
m
Boolean[]
[(Mode)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
b
(Index)i.
_new
m

[(Size)i.]
_next
m
b

_put
m

(Value)b(Index)i.
#Byte[]
Array
C
FromString
M
Byte[]
(String)s
Add
m

(Value)c[(Index)i]
Copy
m
Byte[]
[(Start)i(Length)i]
Delete
m
Byte[]
(Start)i[(Length)i]
Exist
m
b
(Value)c
Extract
m
Byte[]
(Start)i[(Length)i]
Fill
m

(Value)c[(Start)i(Length)i]
Find
m
i
(Value)c[(Start)i]
Insert
m
Byte[]
(Array)Byte[];[(Pos)i]
Pop
m
c

Push
m

(Value)c
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Byte[]

Sort
m
Byte[]
[(Mode)i]
ToString
m
s
[(Start)i(Length)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
c
(Index)i.
_new
m

[(Size)i.]
_next
m
c

_put
m

(Value)c(Index)i.
#Class


Constant
C
i
5
Event
C
i
4
Method
C
i
3
Property
C
i
2
Variable
C
i
1
IsLoaded
M
b
(Name)s
Load
M
Class
(Name)s
AutoCreate
m
o

Exist
m
b
(Symbol)s
New
m
o
[(Arguments)Array;]
_get
m
.Symbol
(Symbol)s
Component
r
Component

Count
r
i

Hidden
r
b

Instance
r
o

Name
r
s

Native
r
b

Parent
r
Class

Symbols
r
String[]

#Classes


_get
M
Class
(Name)s
_next
M
Class

Count
R
i

#Collection

C
Add
m

(Value)v(Key)s
Clear
m


Copy
m
Collection

Exist
m
b
(Key)s
Remove
m

(Key)s
_free
m


_get
m
v
(Key)s
_new
m

[(Mode)i]
_next
m
v

_put
m

(Value)v(Key)s
Default
p
v

Key
p
s

Count
r
i

First
r
s

Last
r
s

Length
r
i

#Component


FindFromPath
M
s
(Path)s
IsLoaded
M
b
(Name)s
Load
M
Component
(Name)s
Path
R
s

Library
r
b

Name
r
s

Version
r
s

#Components


_get
M
Component
(Name)s
_next
M
Component

Count
R
i

#Date[]
Array
C
Add
m

(Value)d[(Index)i]
Copy
m
Date[]
[(Start)i(Length)i]
Delete
m
Date[]
(Start)i[(Length)i]
Exist
m
b
(Value)d
Extract
m
Date[]
(Start)i[(Length)i]
Fill
m

(Value)d[(Start)i(Length)i]
Find
m
i
(Value)d[(Start)i]
Insert
m
Date[]
(Array)Date[];[(Pos)i]
Pop
m
d

Push
m

(Value)d
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Date[]

Sort
m
Date[]
[(Mode)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
d
(Index)i.
_new
m

[(Size)i.]
_next
m
d

_put
m

(Value)d(Index)i.
#Enum


Stop
M


_next
M


Index
P
v

Stopped
R
b

_free
m


#Env


_get
M
s
(Key)s
_next
M
s

_put
M

(Value)s(Key)s
Count
R
i

#Error


Clear
M


Propagate
M


Raise
M

(Message)s
Backtrace
R
String[]

Class
R
Class

Code
R
i

Text
R
s

Where
R
s

#File
Stream

:Read
:


:Resize
:


:Write
:


BaseName
M
s
(Path)s
Dir
M
s
(Path)s
Ext
M
s
(Path)s
IsHidden
M
b
(Path)s
IsRelative
M
b
(Path)s
Load
M
s
(FileName)s
Name
M
s
(Path)s
Save
M

(FileName)s(Data)s
SetBaseName
M
s
(Path)s(NewBaseName)s
SetDir
M
s
(Path)s(NewDir)s
SetExt
M
s
(Path)s(NewExt)s
SetName
M
s
(Path)s(NewName)s
Err
R
File

In
R
File

Out
R
File

_free
m


#Float[]
Array
C
Add
m

(Value)f[(Index)i]
Copy
m
Float[]
[(Start)i(Length)i]
Delete
m
Float[]
(Start)i[(Length)i]
Exist
m
b
(Value)f
Extract
m
Float[]
(Start)i[(Length)i]
Fill
m

(Value)f[(Start)i(Length)i]
Find
m
i
(Value)f[(Start)i]
Insert
m
Float[]
(Array)Float[];[(Pos)i]
Pop
m
f

Push
m

(Value)f
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Float[]

Sort
m
Float[]
[(Mode)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
f
(Index)i.
_new
m

[(Size)i.]
_next
m
f

_put
m

(Value)f(Index)i.
#Integer[]
Array
C
Add
m

(Value)i[(Index)i]
Copy
m
Integer[]
[(Start)i(Length)i]
Delete
m
Integer[]
(Start)i[(Length)i]
Exist
m
b
(Value)i
Extract
m
Integer[]
(Start)i[(Length)i]
Fill
m

(Value)i[(Start)i(Length)i]
Find
m
i
(Value)i[(Start)i]
Insert
m
Integer[]
(Array)Integer[];[(Pos)i]
Pop
m
i

Push
m

(Value)i
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Integer[]

Sort
m
Integer[]
[(Mode)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
i
(Index)i.
_new
m

[(Size)i.]
_next
m
i

_put
m

(Value)i(Index)i.
#Long[]
Array
C
Add
m

(Value)l[(Index)i]
Copy
m
Long[]
[(Start)i(Length)i]
Delete
m
Long[]
(Start)i[(Length)i]
Exist
m
b
(Value)l
Extract
m
Long[]
(Start)i[(Length)i]
Fill
m

(Value)l[(Start)i(Length)i]
Find
m
i
(Value)l[(Start)i]
Insert
m
Long[]
(Array)Long[];[(Pos)i]
Pop
m
l

Push
m

(Value)l
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Long[]

Sort
m
Long[]
[(Mode)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
l
(Index)i.
_new
m

[(Size)i.]
_next
m
l

_put
m

(Value)l(Index)i.
#Object


Address
M
p
(Object)o
Attach
M

(Object)o(Parent)o(Name)s
Call
M
v
(Object)o(Method)s[(Arguments)Array;]
CanRaise
M
b
(Object)o(Event)s
Class
M
Class
(Object)o
Count
M
i
(Object)o
Detach
M

(Object)o
GetProperty
M
v
(Object)o(Property)s
Is
M
b
(Object)o(Class)s
IsLocked
M
b
(Object)o
IsValid
M
b
(Object)o
Lock
M

(Object)o
New
M
o
(Class)s[(Arguments)Array;]
Parent
M
o
(Object)o
Raise
M
b
(Object)o(Event)s[(Arguments)Array;]
SetProperty
M

(Object)o(Property)s(Value)v
SizeOf
M
i
(Object)o
Type
M
s
(Object)o
Unlock
M

(Object)o
#Object[]
Array
C
Add
m

(Value)o[(Index)i]
Copy
m
Object[]
[(Start)i(Length)i]
Delete
m
Object[]
(Start)i[(Length)i]
Exist
m
b
(Value)o
ExistByRef
m
b
(Value)o
Extract
m
Object[]
(Start)i[(Length)i]
Fill
m

(Value)o[(Start)i(Length)i]
Find
m
i
(Value)o[(Start)i]
FindByRef
m
i
(Value)o[(Start)i]
Insert
m
Object[]
(Array)Object[];[(Pos)i]
Pop
m
o

Push
m

(Value)o
Reverse
m
Object[]

Sort
m
Object[]
[(Mode)i]
_get
m
o
(Index)i.
_new
m

[(Size)i.]
_next
m
o

_put
m

(Value)o(Index)i.
#Observer

C
_free
m


_new
m

(Object)o[(After)b]
Tag
p
v

Object
r
o

#Param


_get
M
v
(Index)i
_next
M
v

All
R
Variant[]

Count
R
i

EventName
R
s

Max
R
i

Name
R
s

#Pointer[]
Array
C
Add
m

(Value)p[(Index)i]
Copy
m
Pointer[]
[(Start)i(Length)i]
Delete
m
Pointer[]
(Start)i[(Length)i]
Exist
m
b
(Value)p
Extract
m
Pointer[]
(Start)i[(Length)i]
Fill
m

(Value)p[(Start)i(Length)i]
Find
m
i
(Value)p[(Start)i]
Insert
m
Pointer[]
(Array)Pointer[];[(Pos)i]
Pop
m
p

Push
m

(Value)p
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Pointer[]

Sort
m
Pointer[]
[(Mode)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
p
(Index)i.
_new
m

[(Size)i.]
_next
m
p

_put
m

(Value)p(Index)i.
#Process
Stream

:Error
:

(Error)s
:Kill
:


:Read
:


Crashed
C
i
2
Running
C
i
1
Signaled
C
i
2
Stopped
C
i
0
_exit
M


LastState
R
i

LastValue
R
i

CloseInput
m


Kill
m


Signal
m


Wait
m

[(Timeout)f]
_free
m


_new
m


Ignore
p
b

Handle
r
i

Id
r
i

State
r
i

Value
r
i

#Short[]
Array
C
Add
m

(Value)h[(Index)i]
Copy
m
Short[]
[(Start)i(Length)i]
Delete
m
Short[]
(Start)i[(Length)i]
Exist
m
b
(Value)h
Extract
m
Short[]
(Start)i[(Length)i]
Fill
m

(Value)h[(Start)i(Length)i]
Find
m
i
(Value)h[(Start)i]
Insert
m
Short[]
(Array)Short[];[(Pos)i]
Pop
m
h

Push
m

(Value)h
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Short[]

Sort
m
Short[]
[(Mode)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
h
(Index)i.
_new
m

[(Size)i.]
_next
m
h

_put
m

(Value)h(Index)i.
#Single[]
Array
C
Add
m

(Value)g[(Index)i]
Copy
m
Single[]
[(Start)i(Length)i]
Delete
m
Single[]
(Start)i[(Length)i]
Exist
m
b
(Value)g
Extract
m
Single[]
(Start)i[(Length)i]
Fill
m

(Value)g[(Start)i(Length)i]
Find
m
i
(Value)g[(Start)i]
Insert
m
Single[]
(Array)Single[];[(Pos)i]
Pop
m
g

Push
m

(Value)g
Read
m

(Stream)Stream;[(Start)i(Length)i]
Reverse
m
Single[]

Sort
m
Single[]
[(Mode)i]
Write
m

(Stream)Stream;[(Start)i(Length)i]
_get
m
g
(Index)i.
_new
m

[(Size)i.]
_next
m
g

_put
m

(Value)g(Index)i.
#Stat


_free
m


Auth
r
s

Group
r
s

Hidden
r
b

LastAccess
r
d

LastChange
r
d

LastModified
r
d

Link
r
s

Mode
r
i

Path
r
s

Perm
r
.Stat.Perm

SetGID
r
b

SetUID
r
b

Size
r
l

Sticky
r
b

Time
r
d

Type
r
i

User
r
s

#Stream


Begin
m


Close
m


Drop
m


ReadLine
m
s
[(Escape)s]
Send
m


Watch
m

(Mode)i(Watch)b
_free
m


Blocking
p
b

ByteOrder
p
i

EndOfLine
p
i

Tag
p
v

EndOfFile
r
b

Handle
r
i

IsTerm
r
b

Lines
r
.Stream.Lines

Term
r
.Stream.Term

#String


Byte
M
i
(String)s(Index)i
Chr
M
s
(Unicode)i
Chr$
M
s
(Unicode)i
Code
M
i
(String)s[(Index)i]
Comp
M
i
(String)s(String2)s[(Mode)i]
InStr
M
i
(String)s(Pattern)s[(From)i(Mode)i]
Index
M
i
(String)s(Byte)i
IsValid
M
b
(String)s
LCase
M
s
(String)s
LCase$
M
s
(String)s
Left
M
s
(String)s[(Length)i]
Left$
M
s
(String)s[(Length)i]
Len
M
i
(String)s
Lower
M
s
(String)s
Lower$
M
s
(String)s
Mid
M
s
(String)s(Start)i[(Length)i]
Mid$
M
s
(String)s(Start)i[(Length)i]
Pos
M
i
(String)s(Index)i
RInStr
M
i
(String)s(Pattern)s[(From)i(Mode)i]
Right
M
s
(String)s[(Length)i]
Right$
M
s
(String)s[(Length)i]
UCase
M
s
(String)s
UCase$
M
s
(String)s
UCaseFirst
M
s
(String)s
UCaseFirst$
M
s
(String)s
Upper
M
s
(String)s
Upper$
M
s
(String)s
#String[]
Array
C
Add
m

(Value)s[(Index)i]
Copy
m
String[]
[(Start)i(Length)i]
Delete
m
String[]
(Start)i[(Length)i]
Exist
m
b
(Value)s[(Mode)i]
Extract
m
String[]
(Start)i[(Length)i]
Fill
m

(Value)s[(Start)i(Length)i]
Find
m
i
(Value)s[(Mode)i(Start)i]
Insert
m
String[]
(Array)String[];[(Pos)i]
Join
m
s
[(Separator)s(Escape)s]
Pop
m
s

Push
m

(Value)s
Reverse
m
String[]

Sort
m
String[]
[(Mode)i]
_get
m
s
(Index)i.
_new
m

[(Size)i.]
_next
m
s

_put
m

(Value)s(Index)i.
#System


Architecture
C
s
x86_64
Family
C
s
Cygwin
FullVersion
C
s
3.11.4
Version
C
s
3
Exist
M
b
(Program)s
Find
M
s
(Program)s
GetExternSymbol
M
p
(Library)s(Symbol)s
Log
M

(Message)s
_Breakpoint
M


BreakOnError
P
b

FirstDayOfWeek
P
i

Language
P
s

Profile
P
b

Shell
P
s

Backtrace
R
String[]

ByteOrder
R
i

Charset
R
s

Domain
R
s

Error
R
i

Host
R
s

Path
R
s

RightToLeft
R
b

TimeZone
R
i

User
R
User

#Task


:Error
:

(Data)s
:Kill
:


:Read
:

(Data)s
Stop
m


Wait
m


_free
m


_new
m


Handle
r
i

Running
r
b

Value
r
v

#Timer

C
:Timer
:


_DefaultEvent
C
s
Timer
_Group
C
s
Special
_IsControl
C
b
T
_IsVirtual
C
b
T
_Properties
C
s
Enabled,Delay{Range:0;86400000;10;ms}=1000
Restart
m


Start
m


Stop
m


Trigger
m


_free
m


_new
m

[(Delay)i]
Delay
p
i

Enabled
p
b

#User


Group
R
i

Home
R
s

Id
R
i

Name
R
s

#Variant[]
Array
C
Add
m

(Value)v[(Index)i]
Copy
m
Variant[]
[(Start)i(Length)i]
Delete
m
Variant[]
(Start)i[(Length)i]
Exist
m
b
(Value)v
Extract
m
Variant[]
(Start)i[(Length)i]
Fill
m

(Value)v[(Start)i(Length)i]
Find
m
i
(Value)v[(Start)i]
Insert
m
Variant[]
(Array)Variant[];[(Pos)i]
Pop
m
v

Push
m

(Value)v
Reverse
m
Variant[]

_get
m
v
(Index)i.
_new
m

[(Size)i.]
_next
m
v

_put
m

(Value)v(Index)i.
#gb


Ascent
C
i
0
BigEndian
C
i
1
Binary
C
i
0
Boolean
C
i
1
Byte
C
i
2
Class
C
i
14
Cr
C
s

CrLf
C
s
\n
Currency
C
i
7
Date
C
i
8
Day
C
i
5
Descent
C
i
16
Device
C
i
3
Directory
C
i
2
Exec
C
i
1
File
C
i
1
Fixed
C
i
4
Float
C
i
7
Friday
C
i
5
Function
C
i
13
GeneralDate
C
i
9
GeneralNumber
C
i
2
Hour
C
i
4
IgnoreCase
C
i
1
Integer
C
i
4
International
C
i
8
Language
C
i
2
Lf
C
s
\n
Like
C
i
4
Link
C
i
6
LittleEndian
C
i
0
Long
C
i
5
LongDate
C
i
10
LongTime
C
i
13
Mac
C
i
2
Match
C
i
5
MediumDate
C
i
11
MediumTime
C
i
14
Millisecond
C
i
1
Minute
C
i
3
Monday
C
i
1
Month
C
i
8
Natural
C
i
8
NewLine
C
s
\n
Null
C
i
15
Object
C
i
16
Percent
C
i
5
Pipe
C
i
4
Pointer
C
i
11
Quarter
C
i
9
Read
C
i
4
Saturday
C
i
6
Scientific
C
i
6
Second
C
i
2
Short
C
i
3
ShortDate
C
i
12
ShortNumber
C
i
3
ShortTime
C
i
15
Single
C
i
6
Socket
C
i
5
Standard
C
i
1
String
C
i
9
Sunday
C
i
0
Tab
C
s
\t
Thursday
C
i
4
Tuesday
C
i
2
Unix
C
i
0
Variant
C
i
12
Wednesday
C
i
3
Week
C
i
6
WeekDay
C
i
7
Windows
C
i
1
Write
C
i
2
Year
C
i
10
